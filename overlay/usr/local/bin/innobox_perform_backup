#!/usr/bin/env python
import innobackup

HOLDING_PATH='/innobackup/mediawiki/data/'
METADATA_PATH='/innobackup/mediawiki/metadata/'
MIN_FREEFRAC = 0.5 # Minimum 50% free

def path_exists(path):
	from os import access, F_OK
	return access(path, F_OK)

def get_freefrac(path):
	from os import statvfs
	s = statvfs(path)
	return float(s.f_bavail)/s.f_blocks

def remove_oldest_increment(path):
	dates = innobackup.get_dates()
	oldest_epoch = min([int(x[0]) for x in dates])
	from subprocess import Popen
	p = Popen(['rdiff-backup','--remove-older-than',str(oldest_epoch+1)])
	p.communicate()
	return p.returncode

def make_room(path):
	error_detected = False
	while get_freefrac(path) < MIN_FREEFRAC and not error_detected:
		r = remove_oldest_increment(path)
		if r != 0:
			error_detected = True
	return error_detected

def clear_if_empty(path):
	if not innobackup.get_dates():
		from shutil import rmtree
		rmtree(path, ignore_errors=True)

def copy_localsettings(path):
	from shutil import copy
	copy('/etc/mediawiki/LocalSettings.php',path)

def dump_database(path):
	""" Dump the sql database into a file in the specified directory
            (path).  Return True iff the dump succeeded."""
	from tempfile import mkdtemp
	d = mkdtemp()
	from os.path import join
	dbfilename = join(d,"wiki_db.sql")
	f = open('/etc/mediawiki/wiki_password.txt')
	wiki_password = f.read()
	f.close()
	cmd = "/usr/bin/nice -n 19 mysqldump -uwiki_user -p%s wiki_db -c > %s" % (wiki_password, dbfilename)
	from subprocess import Popen
	p = Popen(cmd,shell=True)
	p.communicate() #wait for the process to finish
	from shutil import move, rmtree
	move(dbfilename,path)
	rmtree(d, ignore_errors=True) #clean up by removing temp directory
	return p.returncode == 0

def rdiff_backup(target):
	cmd = ['rdiff-backup',HOLDING_PATH,target]
	from subprocess import Popen
	p = Popen(cmd)
	p.communicate() #wait for backup to finish
	return p.returncode == 0

def perform_backup():
	if not dump_database(HOLDING_PATH):
		return False
	copy_localsettings(HOLDING_PATH)
	backupdir = innobackup.get_backupdir()
	if backupdir is None:
		return False
	if path_exists(backupdir):
		make_room(backupdir)
	# We call clear_if_empty because of the
	# "Fatal Error: Bad rdiff-backup-data dir on destination side"
	# problem.  If rdiff-backup finds that backupdir/rdiff-backup-data/
	# exists, but contains no current_mirror marker, it will abort.  Even
	# if invoked with --force, it will not proceed with backup.  This is
	# most likely to happen if the first backup fails partway through.  In
	# that event, there will be no available restore dates.  Thus,
	# clear_if_empty checks if there are any available restore dates.  If there
	# are none, we remove the backupdir entirely and start over from scratch.
	# This should avoid the problem.
	clear_if_empty(backupdir)	
	return rdiff_backup(backupdir):

def update_success():
	dates = innobackup.get_dates()
	# get the most recent human-readable date
	maxepoch = 0
	corresponding_date = "None"
	for epoch, date in dates:
		if int(epoch) > maxepoch:
			maxepoch = int(epoch)
			corresponding_date = date
	from os.path import join
	f = open(join(METADATA_PATH,'most_recent_successful_backup'),'w')
	f.write(corresponding_date)
	f.close()

def update_failure():
	import time
	f = open(join(METADATA_PATH,'most_recent_failed_backup'),'w')
	f.write(time.asctime())
	f.close()

if perform_backup():
	update_success()
else:
	update_failure()
