#!/usr/bin/env python
import innobackup

MIN_FREEFRAC = 0.5 # Minimum 50% free

def path_exists(path):
	from os import access, F_OK
	return access(path, F_OK)

def get_freefrac(path):
	from os import statvfs
	s = statvfs(path)
	return float(s.f_bavail)/s.f_blocks

def remove_oldest_increment(path):
	dates = innobackup.get_dates()
	oldest_epoch = min([int(x[0]) for x in dates])
	from subprocess import Popen
	p = Popen(['rdiff-backup','--remove-older-than',str(oldest_epoch+1)])
	p.communicate()
	return p.returncode

def make_room(path):
	error_detected = False
	while get_freefrac(path) < MIN_FREEFRAC and not error_detected:
		r = remove_oldest_increment(path)
		if r != 0:
			error_detected = True
	return error_detected

def clear_if_empty(path):
	if not innobackup.get_dates():
		from shutil import rmtree
		rmtree(path, ignore_errors=True)

def dump_database(path):
	from tempfile import mkdtemp
	d = mkdtemp()
	from os.path import join
	dbfilename = join(d,"wiki_db.sql")
	f = open('/etc/mediawiki/wiki_password.txt')
	wiki_password = f.read()
	f.close()
	cmd = "/usr/bin/nice -n 19 mysqldump -uwiki_user -p%s wiki_db -c > %s" % (wiki_password, dbfilename)
	from subprocess import Popen
	p = Popen(cmd,shell=True)
	p.communicate() #wait for the process to finish
	from shutil import move
	move(dbfilename,path)

def rdiff_backup(target):
	sources = '/usr/share/innobackup/wiki_backup_list'
	cmd = ['rdiff-backup','--include-globbing-filelist',sources,'/',target]
	from subprocess import Popen
	p = Popen(cmd)
	p.communicate() #wait for backup to finish
	return p.returncode	

HOLDING_PATH='/innobackup/mediawiki/'

dump_database(HOLDING_PATH)
backupdir = innobackup.get_backupdir()
if path_exists(backupdir):
	make_room(backupdir)
# We call clear_if_empty because of the
# "Fatal Error: Bad rdiff-backup-data dir on destination side"
# problem.  If rdiff-backup finds that backupdir/rdiff-backup-data/
# exists, but contains no current_mirror marker, it will abort.  Even
# if invoked with --force, it will not proceed with backup.  This is
# most likely to happen if the first backup fails partway through.  In
# that event, there will be no available restore dates.  Thus,
# clear_if_empty checks if there are any available restore dates.  If there
# are none, we remove the backupdir entirely and start over from scratch.
# This should avoid the problem.
clear_if_empty(backupdir)	
rdiff_backup(backupdir)
